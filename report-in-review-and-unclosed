#!/usr/bin/env node

'use strict';

const https = require('https');
const slackPost = require('./slackPost');

const { JIRA_PASS, JIRA_PATH, TNS_TEAM, SLACK_BOT_SERVICE } = process.env;

function httpsRequest(options) {
    return new Promise((resolve, reject) => {
        https
            .get(options, response => {
                let str = '';

                response.on('data', function(chunk) {
                    str += chunk;
                });

                response.on('end', function() {
                    resolve(JSON.parse(str));
                });
            })
            .on('error', e => {
                reject(e);
            });
    });
}

function processResult(data) {
    return data.map(singleIssue => {
        return {
            key: singleIssue.key,
            summary: singleIssue.fields.summary,
            assignee: singleIssue.fields.assignee.name
        };
    });
}

function agregateResult(data) {
    return data.reduce((newArray, singleIssue) => {
        const { assignee } = singleIssue;
        if (Array.isArray(newArray[assignee])) {
            newArray[assignee].push(singleIssue);
        } else {
            newArray[assignee] = [singleIssue];
        }

        return newArray;
    }, {});
}

function agregateResultPerUser(data, assignee) {
    return data.reduce((newArray, singleIssue) => {
        if (assignee === singleIssue.assignee) {
            if (Array.isArray(newArray[assignee])) {
                newArray[assignee].push(singleIssue);
            } else {
                newArray[assignee] = [singleIssue];
            }
        }
        return newArray;
    }, {});
}

function printOut(data) {
    return Object.keys(data).reduce((newString, singleKey) => {
        const ids = data[singleKey].reduce((newStr, singleItem) => {
            return (newStr += `\n https://${JIRA_PATH}/browse/${singleItem.key}`);
        }, '');
        return (newString += `@${singleKey} ${data[singleKey]
            .length}:\n ${ids} \n\n`);
    }, '');
}

function printOutShort(data) {
    return Object.keys(data).reduce((newString, singleKey) => {
        const jql = escape(
            `assignee in (${singleKey}) AND status in (Resolved, "Waiting for release")`
        );
        return (newString += `@${singleKey} ${data[singleKey]
            .length}:\n https://${JIRA_PATH}/issues/?jql=${jql} \n\n`);
    }, '');
}

function performSearch(jql) {
    return new Promise(resolve => {
        httpsRequest({
            host: JIRA_PATH,
            path:
                `/rest/api/2/search?` +
                (jql ? `&jql=${escape(jql)}&maxResults=500` : ''),
            headers: {
                Authorization: 'Basic ' + JIRA_PASS,
                'Content-Type': 'application/json'
            }
        }).then(data => {
            resolve(data.issues);
        });
    });
}

const resolved = `assignee in (${TNS_TEAM}) AND status in (Resolved, "Waiting for release")`;
const inReview = `assignee in (${TNS_TEAM}) AND status = "In Review"`;
const reciever = '';

performSearch(inReview).then(result => {
    const resultArray = processResult(result);
    const uniqueUsers = Object.keys(resultArray.reduce((newObject, singleItem) => {
        return Object.assign(newObject, { [singleItem.assignee]: true });
    }, {}));
    
    uniqueUsers.forEach(singleUser => {
        slackPost(
            '## Tasks in review \n' +
                printOut(agregateResultPerUser(resultArray, singleUser)),
            `@${singleUser}`,
            SLACK_BOT_SERVICE
        );
    })
});

performSearch(resolved).then(result => {
    const resultArray = processResult(result);
    const uniqueUsers = Object.keys(resultArray.reduce((newObject, singleItem) => {
        return Object.assign(newObject, { [singleItem.assignee]: true });
    }, {}));
    
    uniqueUsers.forEach(singleUser => {
        slackPost(
            '## Not closed tasks \n' +
                printOutShort(agregateResultPerUser(resultArray, singleUser)),
            `@${singleUser}`,
            SLACK_BOT_SERVICE
        );
    })
});
